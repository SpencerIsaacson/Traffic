#include "../traffic.h"

void init() {

}
u32 car_length = 64;
u32 car_width = 32;

typedef struct {
float north_bound[5];
float south_bound[5];
float east_bound[5];
float west_bound[5];
} Cars;

Cars cars = (Cars)
{
    .north_bound = {
        900,
        980,
        1060,
        1140,
        1220,
    },
    .south_bound = {
        -900,
        -980,
        -1060,
        -1140,
        -1220,
    },    
    .east_bound = {
        -900,
        -1080,
        -1190,
        -1340,
        -1420,
    },
    .west_bound = {
        900,
        980,
        1060,
        1140,
        1220,
    }        
};

#define north_bound_stop 570
#define south_bound_stop 200
#define east_bound_stop 320
#define west_bound_stop 700

#define follow 140
clock_t last = 0;
double elapsed = 0;
void tick() {
    float speed = 5;
    for (int i = 0; i < 5; ++i)
    {
        float *car = &cars.north_bound[i];
        bool room_to_move = true;
        {
            for (int o = 0; o < 5; ++o){
                if(i != o){
                    float *other = &cars.north_bound[o];
                    if(((*other) < *car) && ((*car) - (*other)) < follow)
                       room_to_move = false;
                }
            }
        }

        if(room_to_move && (*car > (north_bound_stop+16) || *car < (north_bound_stop) || (intersection.lights[Direction_NorthSouth] == LightState_GREEN))) {
            *car -= speed;
            if(*car < -((int)car_length)) {
                *car = H+100;
            }            
        }
    }

    for (int i = 0; i < 5; ++i)
    {
        float *car = &cars.south_bound[i];
        bool room_to_move = true;
        {
            for (int o = 0; o < 5; ++o){
                if(i != o){
                    float *other = &cars.south_bound[o];
                    if(((*car) < *other) && ((*other) - (*car)) < follow)
                       room_to_move = false;
                }
            }
        }

        if(room_to_move && (*car < (south_bound_stop-16) || *car > (south_bound_stop) || (intersection.lights[Direction_NorthSouth] == LightState_GREEN))) {
            *car += speed;
            if(*car > (H+((int)car_length))) {
                *car = -100;
            }             
        }
    }

    for (int i = 0; i < 5; ++i)
    {
        float *car = &cars.east_bound[i];
        bool room_to_move = true;
        {
            for (int o = 0; o < 5; ++o){
                if(i != o){
                    float *other = &cars.east_bound[o];
                    if(((*car) < *other) && ((*other) - (*car)) < follow)
                       room_to_move = false;
                }
            }

        }

        if(room_to_move && ((*car < (east_bound_stop-16)) || *car > (east_bound_stop) || (intersection.lights[Direction_EastWest] == LightState_GREEN))) {
            *car += speed;
            if(*car > (W+((int)car_length))) {
                *car = -100;
            }            
        }
    }

    for (int i = 0; i < 5; ++i)
    {
        float *car = &cars.west_bound[i];
        bool room_to_move = true;
        {
            for (int o = 0; o < 5; ++o){
                if(i != o){
                    float *other = &cars.west_bound[o];
                    if(((*other) < *car) && ((*car) - (*other)) < follow)
                       room_to_move = false;
                }
            }
        }

        if(room_to_move && ((*car > (west_bound_stop+16)) || *car < (west_bound_stop) || (intersection.lights[Direction_EastWest] == LightState_GREEN))) {
            *car -= speed;
            if(*car < -((int)car_length)) {
                *car = W+100;
            }
        }
    }        
}

void render();

#define TIME_STEP 0.0166666667
void simulate() {
    //printf("sim\n");
    elapsed += (clock()-last)/((double)CLOCKS_PER_SEC);
    while(elapsed > TIME_STEP) {
        //printf("tick\n");
        tick();
        elapsed -= TIME_STEP;
    }

    traffic_strategy(&intersection);
    last = clock();
    render();
}
//Colors generated by macro to keep channel order correct across platforms (e.g. BGRA on windows, RGBA on raspberry pi 3b).
#define street_white  make_color(0xDD, 0xDD, 0xDD, 0x00)
#define street_yellow make_color(0xDD, 0xDD, 0x00, 0x00)
#define asphalt       make_color(0xAA, 0xAA, 0xAA, 0x00)
#define grass         make_color(0x00, 0x77, 0x00, 0x00)

#define car_teal      make_color(0x00, 0x77, 0x77, 0x00)

Color light_look_up[LightState_count] = {
    [LightState_RED]    = make_color(0xFF, 0x00, 0x00, 0x00),
    [LightState_GREEN]  = make_color(0x00, 0xFF, 0x00, 0x00),
    [LightState_YELLOW] = make_color(0xFF, 0xFF, 0x00, 0x00),
};

u32 light_size = 32;
u32 road_size = 260;
u32 divider_size = 9;
u32 line_length = 42;


Texture background;
Color background_pixels[W*H];
bool background_inited;

void render() {
    //printf("pixels: %d\n", draw_target.pixels);
    //create background ONCE and then cache
    if(!background_inited) {
        //printf("to cache pixels: %d\n", draw_target.pixels);
        Color *pixels = draw_target.pixels;
        draw_target.pixels = background_pixels;
        //printf("background pixels: %d\n", draw_target.pixels);
        background = (Texture){
            .width = W, 
            .height = H,
            .pixels = background_pixels
        };
        fill(grass);

        //east west road
        fill_rect(asphalt,(Rect){ 0, H / 2 - road_size /2, W, road_size } );
        //lane dividers
        fill_rect(street_yellow,(Rect){ 0, H / 2 - divider_size /2, W, divider_size } );
        for (int i = 0; i < 19; ++i) {
            fill_rect(street_white,(Rect){ i * (line_length + 12), H / 2 - road_size / 4 - divider_size / 2, line_length, divider_size } );
            fill_rect(street_white,(Rect){ i * (line_length + 12), H / 2 + road_size / 4 - divider_size / 2, line_length, divider_size } );
        }

        //north south road
        fill_rect(asphalt,(Rect){ W / 2 - road_size /2, 0, road_size, H } );
        //lane dividers
        fill_rect(street_yellow,(Rect){ W / 2 - divider_size /2, 0, divider_size, H } );
        for (int i = 0; i < 12; ++i) {
            fill_rect(street_white,(Rect){ W / 2 - road_size / 4 - divider_size / 2, i * (line_length + 12), divider_size, line_length } );
            fill_rect(street_white,(Rect){ W / 2 + road_size / 4 - divider_size / 2, i * (line_length + 12), divider_size, line_length } );
        }

        //intersection
        fill_rect(asphalt, (Rect){ W / 2 - road_size /2, H / 2 - road_size /2, road_size, road_size });
        draw_target.pixels = pixels;
        //printf("returned to old pixels: %d\n", draw_target.pixels);
        background_inited = true;
    }

    draw_texture(background);

    for (int i = 0; i < 5; ++i) {
        fill_rect(car_teal, (Rect){ 410-(car_width/2), cars.south_bound[i]-(car_length/2), car_width, car_length });
    }

    for (int i = 0; i < 5; ++i) {
        fill_rect(car_teal, (Rect){ 536-(car_width/2), cars.north_bound[i]-(car_length/2), car_width, car_length });
    }

    for (int i = 0; i < 5; ++i) {
        fill_rect(car_teal, (Rect){ cars.east_bound[i]-(car_length/2), 476-(car_width/2), car_length, car_width });
    }

    for (int i = 0; i < 5; ++i) {
        fill_rect(car_teal, (Rect){ cars.west_bound[i]-(car_length/2), 276-(car_width/2), car_length, car_width });
    }    

    int north_start = 220;
    int south_start = 520;
    //north bound lights
    fill_rect(light_look_up[intersection.lights[Direction_NorthSouth]], (Rect){ W / 2 + road_size / 8 - light_size / 2, north_start, light_size, light_size });
    fill_rect(light_look_up[intersection.lights[Direction_NorthSouth]], (Rect){ W / 2 + (3 * road_size / 8) - light_size / 2, north_start, light_size, light_size });
    //south bound lights
    fill_rect(light_look_up[intersection.lights[Direction_NorthSouth]], (Rect){ W / 2 - road_size / 8 - light_size / 2, south_start, light_size, light_size });
    fill_rect(light_look_up[intersection.lights[Direction_NorthSouth]], (Rect){ W / 2 - (3 * road_size / 8) - light_size / 2, south_start, light_size, light_size });
    //east bound lights
    fill_rect(light_look_up[intersection.lights[Direction_EastWest]], (Rect){ 700, H / 2 + road_size / 8 - light_size / 2, light_size, light_size });
    fill_rect(light_look_up[intersection.lights[Direction_EastWest]], (Rect){ 700, H / 2 + (3 * road_size / 8) - light_size / 2, light_size, light_size });
    //west bound lights
    fill_rect(light_look_up[intersection.lights[Direction_EastWest]], (Rect){ 320, H / 2 - road_size / 8 - light_size / 2, light_size, light_size });
    fill_rect(light_look_up[intersection.lights[Direction_EastWest]], (Rect){ 320, H / 2 - (3 * road_size / 8) - light_size / 2, light_size, light_size });

    //draw_vertical(car_teal, west_bound_stop);
    //draw_vertical(car_teal, east_bound_stop);
    //draw_horizontal(car_teal, north_bound_stop);
    //draw_horizontal(car_teal, south_bound_stop);

    //printf("finished render\n");
}